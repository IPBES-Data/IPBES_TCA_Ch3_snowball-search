---
title: "Snowball Search and global quantification of the references"
format:
    html:
        toc: true
        toc-depth: 2
        embed-resources: true
        code-fold: true
        code-summary: "Show the code"
---

# Setup
```{r}
#| label: setup
#|

library(bibtex)
library(openalexR)
library(writexl)
library(tibble)
library(dplyr)
library(IPBES.R)
library(ggraph)
library(tidygraph)

# library(ggplot2)
# library(knitr)

kp <- bibtex::read.bib("./key-paper.bib")
dois <- sapply(
    kp,
    function(x) {
        x$doi
    }
)

```

# Searches

## OpenAlex

### Setup OpelAnex usage and do snowball serarch

```{r}
#| label: openalex_prep
#|

key_works <- oa_fetch(
    entity = "works",
    doi = dois,
    verbose = FALSE
)

ids <- openalexR:::shorten_oaid(key_works$id)

# citing_kp <- lapply(
#     ids,
#     function(id) {
#         oa_fetch(
#             entity = "works",
#             output = "tibble",
#             cites = id,
#             verbose = FALSE
#         )
#     }
# )
# names(citing_kp) <- ids

# cited_by_kp <- lapply(
#     ids,
#     function(id) {
#         oa_fetch(
#             entity = "works",
#             output = "tibble",
#             cited_by = id,
#             verbose = FALSE
#         )
#     }
# )
# names(cited_by_kp) <- ids

fn <- file.path("data", "snowball.rds")
if (file.exists(fn)) {
    snowball <- readRDS(fn)
} else {
    snowball <- oa_snowball(
        identifier = ids,
        verbose = FALSE
    )
    saveRDS(snowball, fn)
}

flat_snow <- snowball2df(snowball) |>
    tibble::as_tibble()

key_works_cit <- list(
    c(cit = "Fisher et al. 2022", id = "W4220786370"),
    c(cit = "Patterson et al. 2017", id = "W2520670351"),
    c(cit = "Feola et al. 2015", id = "W2020319093"),
    c(cit = "Loorbach et al. 2017", id = "W2204133637"),
    c(cit = "Scoones et al. 2020", id = "W3001406994"),
    c(cit = "Evans et al. 2023", id = "W4379647013")
)
```

### Save snowball as Excel file (`snowball_excel.xlsx`)

```{r}
#| label: openalex_excel
fn <- file.path(".", "data", "snowball_.xlsx")
if (!file.exists(fn)){
    IPBES.R::to_xlsx(snowball, fn)
}
```

### Graph of links between references

```{r}
#| label: openalex_graph
#|

snowball$nodes$cited_by_count_by_year <- snowball$nodes$cited_by_count / (2024 - snowball$nodes$publication_year)

snowball_p <- snowball

for (i in seq_along(key_works_cit)) {
    snowball_p$nodes$id[snowball_p$nodes$id %in% key_works_cit[[i]]["id"]] <- key_works_cit[[i]]["cit"]
    snowball_p$edges$from[snowball_p$edges$from %in% key_works_cit[[i]]["id"]] <- key_works_cit[[i]]["cit"]
    snowball_p$edges$to[snowball_p$edges$to %in% key_works_cit[[i]]["id"]] <- key_works_cit[[i]]["cit"]
}

IPBES.R::plot_snowball(snowball_p, name = "snowball", path = "figures")
rm(snowball_p)
```
![Cited by count](figures/snowball_cited_by_count.png)

### Supplemented by edges between all papers

```{r}
#| label: openalex_supplement
#| 

fn <- file.path("data", "snowball_supplemented.rds")
if (file.exists(fn)) {
    snowball_supplemented <- readRDS(fn)
} else {
    new_edges <- tibble(
        from = character(0),
        to = character(0)
    )

    works <- snowball$nodes$id

    for (i in 1:nrow(snowball$nodes)) {
        from <- works[[i]]
        to <- gsub("https://openalex.org/", "", snowball$nodes$referenced_works[[i]])
        to_in_works <- to[to %in% works]
        if (length(to_in_works) > 0) {
            new_edges <- add_row(
                new_edges,
                tibble(
                    from = from,
                    to = to_in_works
                )
            )
        }
    }

    snowball_supplemented <- snowball
    snowball_supplemented$edges <- add_row(snowball_supplemented$edges, new_edges) |>
        distinct()
}
snowball_p <- snowball_supplemented

for (i in seq_along(key_works_cit)) {
    snowball_p$nodes$id[snowball_p$nodes$id %in% key_works_cit[[i]]["id"]] <- key_works_cit[[i]]["cit"]
    snowball_p$edges$from[snowball_p$edges$from %in% key_works_cit[[i]]["id"]] <- key_works_cit[[i]]["cit"]
    snowball_p$edges$to[snowball_p$edges$to %in% key_works_cit[[i]]["id"]] <- key_works_cit[[i]]["cit"]
}

IPBES.R::plot_snowball(snowball_p, name = "snowball_supplemented", path = "figures")

rm(snowball_p)

fn <- file.path(".", "data", "snowball_supplemented.xlsx")
if (!file.exists(fn)){
    IPBES.R::to_xlsx(snowball_supplemented, file.path(".", "data", "snowball_supplemented.xlsx"))
}
```
![Supplemented Cited by count](figures/snowball_supplemented_cited_by_count.png)

### Identification of references with more than one edge

This is the number of connections (`connection_count)`of the paper (`id`)

```{r}
#| label: openalex_edgecount
#|

mult_edge <- flat_snow |>
    select(id, connection_count) |>
    filter(connection_count > 1) |>
    arrange(desc(connection_count))

links <- flat_snow |>
    filter(id %in% mult_edge$id)

links |>
    select(id, display_name, publication_year, doi, connection_count) |>
    arrange(desc(connection_count)) |>
    knitr::kable()
```


### Identification of Concepts

OpenAlex assigns all works concepts. The concepts are in hirarchical order, ranging from 0 to 3. The higher the number, the more specific the concept. The concepts are assigned to the paper (`id`)


#### Level 0
```{r}
#| label: l0
#| 

x <- lapply(
    flat_snow[["concepts"]],
    FUN = function(x) {
        x[["display_name"]][x[["level"]] == 0]
    }
) |>
    unlist() |>
    table() |>
    as.data.frame() |> 
    rename(
        l0_concept = Var1,
        count = Freq
    ) |>
    arrange(desc(count))

writexl::write_xlsx(x, file.path(".", "data", "concepts_l0.xlsx"))

knitr::kable(x)
```

#### Level 1
```{r}
#| label: l1
#| 

x <- lapply(
    flat_snow[["concepts"]],
    function(x) {
        x[["display_name"]][x[["level"]] == 1]
    }
) |>
    unlist() |>
    table() |>
    as.data.frame() |> 
    rename(
        l1_concept = Var1,
        count = Freq
    ) |>
    arrange(desc(count))
    
writexl::write_xlsx(x, file.path(".", "data", "concepts_l1.xlsx"))

knitr::kable(x)
```

#### Level 2

```{r}
#| label: l2
#| 

x <- lapply(
    flat_snow[["concepts"]],
    function(x) {
        x[["display_name"]][x[["level"]] == 2]
    }
) |>
    unlist() |>
    table() |>
    as.data.frame() |> 
    rename(
        l2_concept = Var1,
        count = Freq
    ) |>
    arrange(desc(count))
    
writexl::write_xlsx(x, file.path(".", "data", "concepts_l2.xlsx"))

knitr::kable(x)
```

#### Level 3

```{r}
#| label: l3
#| 

x <- lapply(
    flat_snow[["concepts"]],
    function(x) {
        x[["display_name"]][x[["level"]] == 3]
    }
) |>
    unlist() |>
    table() |>
    as.data.frame() |> 
    rename(
        l3_concept = Var1,
        count = Freq
    ) |>
    arrange(desc(count))
    
writexl::write_xlsx(x, file.path(".", "data", "concepts_l3.xlsx"))

knitr::kable(x)
```

#### Level 4

```{r}
#| label: l4
#| 

x <- lapply(
    flat_snow[["concepts"]],
    function(x) {
        x[["display_name"]][x[["level"]] == 4]
    }
) |>
    unlist() |>
    table() |>
    as.data.frame() |> 
    rename(
        l4_concept = Var1,
        count = Freq
    ) |>
    arrange(desc(count))
    
writexl::write_xlsx(x, file.path(".", "data", "concepts_l4.xlsx"))
    
knitr::kable(x)
```

#### Level 5

```{r}
#| label: l5
#| 

x <- lapply(
    flat_snow[["concepts"]],
    function(x) {
        x[["display_name"]][x[["level"]] == 5]
    }
) |>
    unlist() |>
    table() |>
    as.data.frame() |> 
    rename(
        l5_concept = Var1,
        count = Freq
    ) |>
    arrange(desc(count))
    
writexl::write_xlsx(x, file.path(".", "data", "concepts_l5.xlsx"))

knitr::kable(x)
```


# Get number of papers cited by keypapers
```{r}
keypapers <- c("W4379647013", "W4220786370", "W2020319093", "W3001406994", "W2520670351", "W2204133637")
snowball$edges |>
    filter(from %in% keypapers) |>
    select(from) |>
    table() |>
    sum()

snowball$edges |>
    filter(from %in% keypapers) |>
    select(to) |>
    unique() |>
    table() |>
    sum()
```


# TODO
iGraph clustering of the snowball graph and especially snowball_supplemented graph

https://stackoverflow.com/questions/44372499/igraph-split-graph-into-clusters

https://rdocumentation.org/packages/igraph/versions/1.3.5/topics/cluster_edge_betweenness

https://stackoverflow.com/questions/53249609/r-igraph-plot-communies-and-selectively-highlight-some